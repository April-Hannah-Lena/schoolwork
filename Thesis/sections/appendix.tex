% -------------------------------------------------------------------------------------- %

\section{Appendix}

\begin{jllisting}[language=julia, style=jlcodestyle, label=lst:boxmap, caption=Function to calculate $f(\mathcal{B})$]
    function map_boxes(g::SampledBoxMap, source::BoxSet)
        P = source.partition

        # Use multithreaded iteration over the box set
        @floop for box in source
            c, r = box.center, box.radius
            domain_points = g.domain_points(c, r)

            # Map each test point
            for p in domain_points
                fp = g.map(p)
                hitbox = point_to_box(P, fp)

                # Skip to next iteration if `fp` lands outside `P`
                isnothing(hitbox) && continue

                # Add perturbations to fp
                r = hitbox.radius
                image_points = g.image_points(c, r)
                for ip in image_points
                    hit = point_to_key(P, ip)
                    isnothing(hit) && continue

                    # Use @reduce syntax to initialize an empty
                    # key set and add hits during iteration
                    @reduce(image = union!(Set{keytype(P)}(), hit))
                end
            end
        end
        return BoxSet(P, image)
    end 
\end{jllisting}

\begin{jllisting}[language=julia, style=jlcodestyle, label=lst:boxmap_cpu, caption=Function to calculate $f(\mathcal{B})$ with CPU acceleration]
    function map_boxes(
            g::SampledBoxMap{C,N}, source::BoxSet
        ) where {simd,C<:BoxMapCPUCache{simd},N}
        
        # Preallocated temporary storage objects.
        # `temp_vec` and `temp_points` are reinterprets of
        # the same array, `temp_points` is an array of tuples
        idx_base, temp_vec, temp_points = g.acceleration
        
        P = source.partition
        @floop for box in source

            # Grab a separate section of the
            # temporary storage for each thread
            tid  = (threadid() - 1) * simd
            idx  = idx_base + tid * N
            mapped_points = @view temp_points[tid+1:tid+simd]

            domain_points = g.domain_points(box.center, box.radius)
            for p in domain_points
                fp = g.map(p)

                # Scatter packed `fp` into temporary storage
                tuple_vscatter!(temp_vec, fp, idx)

                # continue as with normal `map_boxes`
                for q in mapped_points
                    hitbox = point_to_box(P, q)
                    isnothing(hitbox) && continue
                    image_points = g.image_points(q,  hitbox.radius)
                    for ip in image_points
                        hit = point_to_key(P, ip)
                        isnothing(hit) && continue
                        @reduce(image = union!(Set{keytype(P)}(), hit))
                    end
                end
            end
        end
        return BoxSet(P, image)
    end
\end{jllisting}

\begin{jllisting}[language=julia, style=jlcodestyle, label=lst:gpu_kernel, caption=GPU kernel to calculate $f(\mathcal{B})$]
    function map_boxes_kernel(
            f,          # Function
            keys,       # Keys to be mapped
            points,     # "Global" test points
            out_keys,   # Array to hold mapped box indices ...
            P,          # ... wrt the partition P
        )

        # Calculate the index of the GPU thread
        ind = (blockIdx().x - 1) * blockDim().x + threadIdx().x - 1
        stride = gridDim().x * blockDim().x
        nk, np = length(keys), length(points)
        len = nk * np - 1

        # In case `len` is too large, launch the warp repeatedly
        for i in ind : stride : len
        
            # Loop over the test points, then the box index
            m, n = divrem(i, np) .+ 1
            p    = points[m]
            key  = keys[n]
            box  = key_to_box(P, key)
            c, r = box.center, box.radius

            # Map the point forward and record the result
            fp   = f(@muladd p .* r .+ c)
            hit  = point_to_key(P, fp)

            # If `fp` lands outside the partition, assign it the
            # out-of-bounds index 0. This will later be discarded
            out_keys[i+1] = isnothing(hit) ? hit : 0

        end
    end
\end{jllisting}

\begin{jllisting}[language=julia, style=jlcodestyle, label=lst:boxmap_gpu, caption=Function to calculate $f(\mathcal{B})$ with GPU acceleration]
    function map_boxes(
            g::SampledBoxMap{C}, source::BoxSet
        ) where {SZ,C<:BoxMapGPUCache{SZ}}
        # BoxMapGPUCache holds a max size `SZ` of box indices 
        # which can fit in GPU memory

        # We use `Stateful` to iterate through
        # test points `SZ` points at a time
        P, keys = source.partition, Stateful(source.set)

        # Normalized test points
        points = g.domain_points(P.domain.center, P.domain.radius)

        image = Set{keytype(P)}()
        while !isnothing(keys.nextvalstate)
            stride = min(SZ, length(keys))

            # Allocate input/output indices on GPU
            in_keys = CuArray{Int32,1}(collect(Int32, take(keys, stride)))
            out_keys = CuArray{Int32,1}(undef, length(in_keys) * length(points))

            # Launch GPU kernel and wait until task is comlete
            launch_kernel_then_sync!(
                map_boxes_kernel!, 
                g.map, in_keys, points, out_keys, P
            )
            
            # Transfer output indices to CPU memory
            out_cpu = Array{Int32,1}(out_keys)
            union!(image, out_cpu)

            # Manually deallocate GPU arrays since julia has 
            # more difficulty garbage collecting GPU memory
            CUDA.unsafe_free!(in_keys); CUDA.unsafe_free!(out_keys)
        end

        # remove out-of-bounds index
        delete!(image, 0i32)

        return BoxSet(P, image)
    end
\end{jllisting}

% -------------------------------------------------------------------------------------- %